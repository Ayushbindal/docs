const crypto = require('crypto');

const moduleRequire = require('./moduleRequire');

const _ = moduleRequire('lodash');

//
//
// RoomEvents
//
//
const v1ToV2RootMap = ['clid' /* this is the old _id, now it is called "client id" because it is generated by the client */, 'pids', 'v', 'ts', 'src', 'cid', 't', 'd', 'updatedAt', 'deletedAt'];

function fromV1Data(message) {
	return { ..._.omit(message, this.v1ToV2RootMap), t: message.t || 'msg', u: message.u, msg: message.msg };
}

//
//
// Events
//
//
const RoomEventTypeDescriptor = {
	ROOM: 'room', // create new room
	DELETE_ROOM: 'droom', // delete room
	PRUNE_ROOM_MESSAGES: 'prune', // prune messages from room
	MESSAGE: 'msg', // new message
	EDIT_MESSAGE: 'emsg', // edit a message content
	DELETE_MESSAGE: 'dmsg', // delete message

	// Not yet implemented
	// ADD_USER:'add_user',
	// REMOVE_USER:'remove_user',
	// SET_MESSAGE_REACTION:'set_message_reaction',
	// UNSET_MESSAGE_REACTION:'unset_message_reaction',
	// MUTE_USER:'mute_user',
	// UNMUTE_USER:'unmute_user',
};

const dataHashOptionsDefinition = [
	{
		t: [RoomEventTypeDescriptor.MESSAGE, RoomEventTypeDescriptor.EDIT_MESSAGE],
		options: {
			include: ['t', 'u', 'msg'],
		},
	},
];

const dataHashOptions = dataHashOptionsDefinition.reduce((acc, item) => {
	for (const t of item.t) {
		acc[t] = item.options;
	}

	return acc;
}, {});

function SHA256(content) {
	return crypto.createHash('sha256').update(content).digest('hex');
}

function getEventIdHash(contextQuery, event) {
	return SHA256(`${ event.src }${ JSON.stringify(contextQuery) }${ event.pids.join(',') }${ event.t }${ event.ts }${ event.dHash }`);
}

function getEventDataHash(event) {
	// Always use the consolidated (o), unchanged data
	let data = event.o;

	const options = dataHashOptions[event.t];

	if (options) {
		if (options.include) { data = _.pick(data, options.include); }
		if (options.skip) { data = _.omit(data, options.skip); }
	}

	return SHA256(JSON.stringify(data));
}

function buildEvent(src, clid, cid, t, d, pids = [], addIsLeaf = false) {
	const contextQuery = { ct: 'room', cid };

	const event = {
		pids,
		v: 2,
		ts: new Date(),
		src,
		...contextQuery,
		t,
		dHash: '',
		o: d,
		d,
	};

	//
	// Add clid if it exists
	if (clid) {
		event.clid = clid;
	}

	//
	// Create the data hash
	event.dHash = getEventDataHash(event);

	if (addIsLeaf) {
		event.isLeaf = true;
	}

	event._id = getEventIdHash(contextQuery, event);

	return event;
}

//
// Export
//
module.exports = {
	RoomEvents: {
		v1ToV2RootMap,
		fromV1Data,
	},
	Events: {
		SHA256,
		getEventIdHash,
		getEventDataHash,
		buildEvent,
	},
};
