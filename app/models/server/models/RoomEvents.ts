import _ from 'lodash';
import { TAPi18n } from 'meteor/rocketchat:tap-i18n';

import { IRoomEventDataRoom } from '../../../events/definitions/room/data/IRoomEventDataRoom';
import { IRoomEventDataMessage } from '../../../events/definitions/room/data/IRoomEventDataMessage';
import {
	EventContext,
	EventDataDefinition,
	IEvent,
	IEventData,
} from '../../../events/definitions/IEvent';
import { IRoom } from '../../../events/definitions/room/IRoom';
import { RoomEventTypeDescriptor } from '../../../events/definitions/room/IRoomEvent';
import { IEventDataUpdate } from '../../../events/definitions/data/IEventDataUpdate';
import { IEventDataEmpty } from '../../../events/definitions/data/IEventDataEmpty';
import { EventsModel, IAddEventResult, IContextQuery, IEventStub } from './Events';
import { getLocalSrc } from '../../../events/server/lib/getLocalSrc';

const getContextQuery = (param: string | IEvent<any>): IContextQuery => {
	let cid: string;

	if (typeof param === 'string') {
		cid = param;
	} else {
		cid = param.cid;
	}

	return { ct: EventContext.ROOM, cid };
};

class RoomEventsModel extends EventsModel {
	readonly v1ToV2RootMap = ['clid' /* this is the old _id, now it is called "client id" because it is generated by the client */, 'pids', 'v', 'ts', 'src', 'cid', 't', 'd', 'updatedAt', 'deletedAt'];

	constructor() {
		super('room_event');

		this.tryEnsureIndex({ 'd.u._id': 1 }, { sparse: true });
		this.tryEnsureIndex({ cid: 1, t: 1, 'd.u._id': 1 }, { sparse: true });
		this.tryEnsureIndex({ 'd.expireAt': 1 }, { expireAfterSeconds: 0 });
		this.tryEnsureIndex({ 'd.msg': 'text' }, { sparse: true });
		this.tryEnsureIndex({ 'd.file._id': 1 }, { sparse: true });
		this.tryEnsureIndex({ 'd.mentions.username': 1 }, { sparse: true });
		this.tryEnsureIndex({ 'd.pinned': 1 }, { sparse: true });
		this.tryEnsureIndex({ 'd.snippeted': 1 }, { sparse: true });
		this.tryEnsureIndex({ 'd.location': '2dsphere' });
		this.tryEnsureIndex({ 'd.unread': 1 }, { sparse: true });

		// slack bridge
		this.tryEnsureIndex({ 'd.slackBotId': 1, 'd.slackTs': 1 }, { sparse: true });

		// discussions
		this.tryEnsureIndex({ 'd.drid': 1 }, { sparse: true });
		// threads
		this.tryEnsureIndex({ 'd.tmid': 1 }, { sparse: true });
		this.tryEnsureIndex({ 'd.tcount': 1, tlm: 1 }, { sparse: true });
		// livechat
		this.tryEnsureIndex({ 'd.navigation.token': 1 }, { sparse: true });
	}

	public ensureSrc(src: string) {
		return src || getLocalSrc();
	}

	public async addRoomEvent<T extends EventDataDefinition>(event: IEvent<T>): Promise<IAddEventResult> {
		return super.addEvent(getContextQuery(event), event);
	}

	public async updateRoomEventData<T extends EventDataDefinition>(event: IEvent<T>, dataToUpdate: IEventDataUpdate<IEventData>): Promise<void> {
		return super.updateEventData(getContextQuery(event), event.t, dataToUpdate, event.clid);
	}

	public async flagRoomEventAsDeleted<T extends EventDataDefinition>(event: IEvent<T>): Promise<void> {
		return super.flagEventAsDeleted(getContextQuery(event), event.t, new Date(), event.clid);
	}

	public async createRoomGenesisEvent(src: string, room: IRoom): Promise<IEvent<IRoomEventDataRoom>> {
		src = this.ensureSrc(src);

		const event: IRoomEventDataRoom = { room };

		return super.createGenesisEvent(src, getContextQuery(room._id), RoomEventTypeDescriptor.ROOM, event);
	}

	public async createMessageEvent<T extends IRoomEventDataMessage>(src: string, roomId: string, clid: string, d: T): Promise<IEvent<T>> {
		src = this.ensureSrc(src);

		const stub: IEventStub<T> = {
			clid,
			t: RoomEventTypeDescriptor.MESSAGE,
			d,
		};

		return super.createEvent(src, getContextQuery(roomId), stub);
	}

	public async createEditMessageEvent<T extends IEventDataUpdate<IRoomEventDataMessage>>(src: string, roomId: string, clid: string, d: T): Promise<IEvent<T>> {
		src = this.ensureSrc(src);

		const stub: IEventStub<T> = {
			clid,
			t: RoomEventTypeDescriptor.EDIT_MESSAGE,
			d,
		};

		return super.createEvent(src, getContextQuery(roomId), stub);
	}

	public async createDeleteMessageEvent(src: string, roomId: string, clid?: string): Promise<IEvent<IEventDataUpdate<IEventDataEmpty>>> {
		src = this.ensureSrc(src);

		const stub: IEventStub<IEventDataUpdate<IEventDataEmpty>> = {
			clid,
			t: RoomEventTypeDescriptor.DELETE_MESSAGE,
			d: {},
		};

		return super.createEvent(src, getContextQuery(roomId), stub);
	}

	public async createDeleteRoomEvent(src: string, roomId: string): Promise<IEvent<IEventDataUpdate<IEventDataEmpty>>> {
		src = this.ensureSrc(src);

		const stub: IEventStub<IEventDataUpdate<IEventDataEmpty>> = {
			t: RoomEventTypeDescriptor.DELETE_ROOM,
			d: {},
		};

		return super.createEvent(src, getContextQuery(roomId), stub);
	}

	public async createPruneMessagesEvent(query: any, roomId: string, userId: string): Promise<{
		count: number;
		filesIds: Array<string>;
		discussionsIds: Array<string>;
	}> {
		const pruneEvent = await super.createEvent(getLocalSrc(), getContextQuery(roomId), {
			t: RoomEventTypeDescriptor.PRUNE_ROOM_MESSAGES,
			d: {
				query: JSON.stringify(query),
				u: {
					_id: userId,
				},
			},
		});

		this.addRoomEvent(pruneEvent);

		const filesIds: Array<string> = [];
		const discussionsIds: Array<string> = [];
		const modifier = (event: IEvent<IRoomEventDataMessage>): {[key: string]: Function} => ({
			msg: (): void => {
				this.update({
					_id: event._id,
				}, {
					$set: {
						'd.msg': '',
					},
					$currentDate: { deletedAt: true },
				});
			},
			discussion: (): void => {
				const { d } = event;
				const { drid = '' } = d;
				discussionsIds.push(drid);
				this.update({
					_id: event._id,
				}, {
					$currentDate: { deletedAt: true },
				});

				this.model.rawCollection().updateMany({
					rid: { $eq: drid },
					t: { $eq: 'msg' },
				}, {
					$set: {
						'd.msg': '',
						'd.attachments': [],
					},
					$unset: { 'd.file': 1 },
					$currentDate: { deletedAt: true },
				});
			},
			file: (): void => {
				const { d } = event;
				const { file = { _id: '' } } = d;
				filesIds.push(file._id);
				this.update({
					_id: event._id,
				}, {
					$unset: { 'd.file': 1 },
					$set: { 'd.attachments': [{ color: '#FD745E', prunedText: `_${ TAPi18n.__('File_removed_by_prune') }_` }] },
					$currentDate: { deletedAt: true },
				});
			},
		});

		const results: Array<IEvent<IRoomEventDataMessage>> = await this.model.rawCollection().find({
			'd.msg': { $exists: true },
			...query,
		}).toArray();

		for (let i = 0; results.length > i; i++) {
			// identify what type of data is the current one
			const { d: data } = results[i];
			if (data && data.file && data.file._id) {
				modifier(results[i]).file();
				continue;
			} else if (data && data.drid) {
				modifier(results[i]).discussion();
				continue;
			} else {
				modifier(results[i]).msg();
				continue;
			}
		}

		return {
			count: results.length,
			filesIds,
			discussionsIds,
		};
	}

	// async createAddUserEvent(src, roomId, user, subscription, domainsAfterAdd) {
	// 	return super.createEvent(src, getContextQuery(roomId), eventTypes.ROOM_ADD_USER, { roomId, user, subscription, domainsAfterAdd });
	// }

	// async createRemoveUserEvent(src, roomId, user, domainsAfterRemoval) {
	// 	return super.createEvent(src, getContextQuery(roomId), eventTypes.ROOM_REMOVE_USER, { roomId, user, domainsAfterRemoval });
	// }

	// async createDeleteMessageEvent(src, roomId, messageId) {
	// 	return super.createEvent(src, getContextQuery(roomId), eventTypes.ROOM_DELETE_MESSAGE, { roomId, messageId });
	// }

	// async createSetMessageReactionEvent(src, roomId, messageId, username, reaction) {
	// 	return super.createEvent(src, getContextQuery(roomId), eventTypes.ROOM_SET_MESSAGE_REACTION, { roomId, messageId, username, reaction });
	// }

	// async createUnsetMessageReactionEvent(src, roomId, messageId, username, reaction) {
	// 	return super.createEvent(src, getContextQuery(roomId), eventTypes.ROOM_UNSET_MESSAGE_REACTION, { roomId, messageId, username, reaction });
	// }

	// async createMuteUserEvent(src, roomId, user) {
	// 	return super.createEvent(src, getContextQuery(roomId), eventTypes.ROOM_MUTE_USER, { roomId, user });
	// }

	// async createUnmuteUserEvent(src, roomId, user) {
	// 	return super.createEvent(src, getContextQuery(roomId), eventTypes.ROOM_UNMUTE_USER, { roomId, user });
	// }

	// async removeRoomEvents(roomId) {
	// 	return super.removeContextEvents(getContextQuery(roomId));
	// }

	//
	// Backwards compatibility
	//
	public belongsToV2Root(property: string): boolean {
		return this.v1ToV2RootMap.indexOf(property) !== -1;
	}

	public fromV1Data(message: IRoomEventDataMessage): IRoomEventDataMessage {
		return { ..._.omit(message, this.v1ToV2RootMap), t: message.t || 'msg', u: message.u, msg: message.msg };
	}

	public toV1(event: any) {
		return {
			..._.omit(event, 'pids', 'clid', 'v', 'dHash', 'src', 'ct', 'cid', 'd'),
			...event.d,
			t: (event.d || {}).t,
			rid: event.cid,
		};
	}
}

export const RoomEvents = new RoomEventsModel();
